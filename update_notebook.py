import json
import os

notebook_path = r"c:\Users\amrit\Desktop\FINAL_DRM\DRM-GA\DRM_Project.ipynb"

new_source = [
    "# PHASE 2: SYNTHETIC OPTION PORTFOLIO (TASK A)\n",
    "# Objective: Construct a synthetic long call using Put-Call Parity\n",
    "# Strategy: Long Stock + Long Put = Long Call\n",
    "# We will also implement Dynamic Delta Hedging (Part A)\n",
    "\n",
    "print(f\"\\n{'=' * 60}\")\n",
    "print(f\"PHASE 2: SYNTHETIC PORTFOLIO & DELTA HEDGING\")\n",
    "print(f\"{'=' * 60}\")\n",
    "\n",
    "# Parameters\n",
    "S0 = float(data['Close'].iloc[0])\n",
    "K = S0  # ATM Option\n",
    "r = 0.06  # Risk-free rate (6%)\n",
    "sigma = vol  # Annualized volatility from Phase 1\n",
    "T_init = 2.0  # 2 Years simulation\n",
    "window = len(data)  # Full history\n",
    "\n",
    "print(f\"Simulation Parameters:\")\n",
    "print(f\"  - Initial Stock Price (S0): {S0:.2f}\")\n",
    "print(f\"  - Strike Price (K): {K:.2f}\")\n",
    "print(f\"  - Risk-Free Rate: {r:.2%}\")\n",
    "print(f\"  - Volatility: {sigma:.2%}\")\n",
    "print(f\"  - Duration: {T_init} Years ({window} trading days)\")\n",
    "\n",
    "# BSM Price Function\n",
    "def bsm_price(S, K, T, r, sigma, option_type='call'):\n",
    "    if T <= 1e-5:\n",
    "        return max(S - K, 0) if option_type == 'call' else max(K - S, 0)\n",
    "    \n",
    "    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n",
    "    d2 = d1 - sigma * np.sqrt(T)\n",
    "    \n",
    "    if option_type == 'call':\n",
    "        price = S * si.norm.cdf(d1, 0.0, 1.0) - K * np.exp(-r * T) * si.norm.cdf(d2, 0.0, 1.0)\n",
    "    elif option_type == 'put':\n",
    "        price = K * np.exp(-r * T) * si.norm.cdf(-d2, 0.0, 1.0) - S * si.norm.cdf(-d1, 0.0, 1.0)\n",
    "    return price\n",
    "\n",
    "# BSM Delta Function\n",
    "def bsm_delta(S, K, T, r, sigma, option_type='call'):\n",
    "    if T <= 1e-5:\n",
    "        if option_type == 'call':\n",
    "            return 1.0 if S > K else 0.0\n",
    "        else:\n",
    "            return -1.0 if S < K else 0.0\n",
    "\n",
    "    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n",
    "    \n",
    "    if option_type == 'call':\n",
    "        return si.norm.cdf(d1)\n",
    "    else:\n",
    "        return si.norm.cdf(d1) - 1\n",
    "\n",
    "# Initial Prices\n",
    "call_init = bsm_price(S0, K, T_init, r, sigma, 'call')\n",
    "put_init = bsm_price(S0, K, T_init, r, sigma, 'put')\n",
    "\n",
    "print(f\"\\nInitial Option Prices (Theoretical):\")\n",
    "print(f\"  - ATM Call Price: {call_init:.2f}\")\n",
    "print(f\"  - ATM Put Price: {put_init:.2f}\")\n",
    "\n",
    "# Storage for Synthetic Portfolio (Static)\n",
    "synth_nav = []\n",
    "dates = []\n",
    "stock_prices = []\n",
    "put_prices = []\n",
    "parity_diff = []\n",
    "\n",
    "# Storage for Delta Hedging (Dynamic)\n",
    "hedged_portfolio_value = []\n",
    "cash_account = []\n",
    "stock_position = []\n",
    "call_position_value = []\n",
    "\n",
    "# Initial Setup for Delta Hedging\n",
    "initial_delta = bsm_delta(S0, K, T_init, r, sigma, 'call')\n",
    "shares_held = initial_delta\n",
    "cash_balance = call_init - (shares_held * S0) # Receive Call Premium, Pay for Stock\n",
    "\n",
    "print(f\"\\nStarting Simulations...\")\n",
    "\n",
    "for i in range(window):\n",
    "    date = data.index[i]\n",
    "    S_t = float(data['Close'].iloc[i])\n",
    "    \n",
    "    # Time to maturity (decaying)\n",
    "    T_t = max(T_init - (i / 252.0), 1e-5)\n",
    "    \n",
    "    # --- 1. Static Synthetic Portfolio Tracking ---\n",
    "    put_price_t = bsm_price(S_t, K, T_t, r, sigma, 'put')\n",
    "    synth_value_t = S_t + put_price_t\n",
    "    \n",
    "    synth_nav.append(synth_value_t)\n",
    "    dates.append(date)\n",
    "    stock_prices.append(S_t)\n",
    "    put_prices.append(put_price_t)\n",
    "    \n",
    "    # Put-Call Parity Check\n",
    "    call_price_t = bsm_price(S_t, K, T_t, r, sigma, 'call')\n",
    "    pv_k = K * np.exp(-r * T_t)\n",
    "    parity_error = (S_t + put_price_t) - (call_price_t + pv_k)\n",
    "    parity_diff.append(parity_error)\n",
    "    \n",
    "    # --- 2. Dynamic Delta Hedging Tracking ---\n",
    "    current_delta = bsm_delta(S_t, K, T_t, r, sigma, 'call')\n",
    "    delta_change = current_delta - shares_held\n",
    "    \n",
    "    # Update Cash (assume risk-free growth on cash balance for 1 day)\n",
    "    dt = 1/252.0\n",
    "    cash_balance = cash_balance * np.exp(r * dt) - (delta_change * S_t)\n",
    "    \n",
    "    shares_held = current_delta\n",
    "    \n",
    "    # Portfolio Value\n",
    "    call_liability = call_price_t\n",
    "    pf_value = (shares_held * S_t) + cash_balance - call_liability\n",
    "    hedged_portfolio_value.append(pf_value)\n",
    "    cash_account.append(cash_balance)\n",
    "    stock_position.append(shares_held)\n",
    "    call_position_value.append(call_liability)\n",
    "\n",
    "# Final Calculations\n",
    "final_synth_value = synth_nav[-1]\n",
    "initial_synth_cost = S0 + put_init\n",
    "pnl_synth = final_synth_value - initial_synth_cost\n",
    "\n",
    "final_hedged_value = hedged_portfolio_value[-1]\n",
    "\n",
    "print(f\"\\nSimulation Complete!\")\n",
    "print(f\"Synthetic Portfolio (Static):\")\n",
    "print(f\"  - Final Value: {final_synth_value:.2f}\")\n",
    "print(f\"  - Initial Cost: {initial_synth_cost:.2f}\")\n",
    "print(f\"  - P&L: {pnl_synth:.2f}\")\n",
    "print(f\"Delta Hedging (Dynamic):\")\n",
    "print(f\"  - Final Hedged P&L: {final_hedged_value:.2f} (Should be close to 0)\")\n",
    "\n",
    "# Create DataFrame for Analysis\n",
    "df_res = pd.DataFrame({\n",
    "    'Date': dates,\n",
    "    'Stock': stock_prices,\n",
    "    'Synthetic': synth_nav,\n",
    "    'Hedged_PnL': hedged_portfolio_value,\n",
    "    'Parity_Error': parity_diff\n",
    "})\n",
    "df_res.set_index('Date', inplace=True)\n",
    "\n",
    "# Visualization\n",
    "fig, axes = plt.subplots(3, 1, figsize=(14, 18))\n",
    "\n",
    "# 1. Synthetic Portfolio\n",
    "axes[0].plot(df_res.index, df_res['Synthetic'], label='Synthetic Call (Long Stock + Long Put)', color='orange')\n",
    "# Calculate Theoretical Call + PV(K) for comparison\n",
    "theo_vals = []\n",
    "for i in range(len(stock_prices)):\n",
    "    S_t = stock_prices[i]\n",
    "    T_t = max(T_init - (i/252.0), 1e-5)\n",
    "    c = bsm_price(S_t, K, T_t, r, sigma, 'call')\n",
    "    theo_vals.append(c + K * np.exp(-r * T_t))\n",
    "axes[0].plot(df_res.index, theo_vals, label='Theoretical Call + PV(K)', linestyle='--', color='blue')\n",
    "axes[0].set_title('Put-Call Parity Check (Static Portfolio)', fontsize=14)\n",
    "axes[0].legend()\n",
    "axes[0].grid(True)\n",
    "\n",
    "# 2. Parity Error\n",
    "axes[1].plot(df_res.index, df_res['Parity_Error'], color='red')\n",
    "axes[1].set_title('Parity Error (Synthetic - Theoretical)', fontsize=14)\n",
    "axes[1].grid(True)\n",
    "\n",
    "# 3. Delta Hedging\n",
    "axes[2].plot(df_res.index, df_res['Hedged_PnL'], color='green')\n",
    "axes[2].set_title('Dynamic Delta Hedging P&L (Cumulative)', fontsize=14)\n",
    "axes[2].axhline(0, color='black', linestyle='--')\n",
    "axes[2].grid(True)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n"
]

try:
    with open(notebook_path, 'r', encoding='utf-8') as f:
        nb = json.load(f)

    cells = nb['cells']
    found = False
    for cell in cells:
        if cell['cell_type'] == 'code':
            source = cell['source']
            if source and len(source) > 0 and source[0].strip().startswith("# PHASE 2: SYNTHETIC OPTION PORTFOLIO"):
                cell['source'] = new_source
                found = True
                break
    
    if found:
        with open(notebook_path, 'w', encoding='utf-8') as f:
            json.dump(nb, f, indent=1)
        print("Successfully updated Phase 2 cell.")
    else:
        print("Phase 2 cell not found.")

except Exception as e:
    print(f"Error: {e}")
