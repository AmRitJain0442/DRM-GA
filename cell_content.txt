Cell 15:
# PHASE 4: CONSOLIDATED EXCEL EXPORT

import os
from datetime import datetime

print(f"{'=' * 70}")
print(f"CONSOLIDATED EXCEL EXPORT")
print(f"{'=' * 70}")

# 1. Summary Statistics
df_summary = pd.DataFrame({
    'Metric': [
        'Ticker Symbol', 'Analysis Date', 'Data Start Date', 'Data End Date',
        'Total Trading Days', 'Starting Price (INR)', 'Ending Price (INR)',
        'Max Price (INR)', 'Min Price (INR)', 'Mean Price (INR)',
        'Total Return (%)', 'Annualized Return (%)', 'Daily Volatility',
        'Annualized Volatility (%)', 'Volatility Classification', 'Risk-Free Rate (%)',
        'Mean Daily Return', 'Skewness', 'Kurtosis'
    ],
    'Value': [
        ticker, datetime.now().strftime('%Y-%m-%d'),
        data.index[0].strftime('%Y-%m-%d'), data.index[-1].strftime('%Y-%m-%d'),
        len(data), f"{p_start:.2f}", f"{p_end:.2f}", f"{p_max:.2f}",
        f"{p_min:.2f}", f"{p_mean:.2f}", f"{ret_total*100:.2f}",
        f"{ret_annual*100:.2f}", f"{daily_vol:.6f}", f"{vol*100:.2f}",
        'LOW' if vol < 0.15 else 'MODERATE' if vol < 0.25 else 'HIGH' if vol < 0.35 else 'VERY HIGH',
        "6.00", f"{data['Log_Returns'].mean():.6f}",
        f"{data['Log_Returns'].skew():.4f}", f"{data['Log_Returns'].kurtosis():.4f}"
    ]
})

# 2. Stock Price Data
df_stock = data[['Close', 'Log_Returns']].copy()
df_stock['Date'] = df_stock.index.strftime('%Y-%m-%d')
df_stock = df_stock.reset_index(drop=True)[['Date', 'Close', 'Log_Returns']]
df_stock.columns = ['Date', 'Close_Price', 'Log_Returns']

# 3. Synthetic Portfolio Tracking
df_synthetic = df_res.reset_index()
df_synthetic['Date'] = df_synthetic['Date'].dt.strftime('%Y-%m-%d')

# 4. Task A Comparison
df_task_a = pd.DataFrame({
    'Metric': ['Initial Cost', 'Final Payoff', 'Profit/Loss', 'Return on Capital (%)'],
    'Actual_Call': [cost_call, payoff_call, pnl_call, roc_call],
    'Synthetic_Call': [cost_synth, payoff_synth, pnl_synth, roc_synth]
})

# 5. Option Pricing Summary
df_pricing = pd.DataFrame({
    'Model': ['BSM', 'BSM', 'Binomial (N=250)', 'Binomial (N=250)'],
    'Option_Type': ['Call', 'Put', 'Call', 'Put'],
    'Price': [bsm_c, bsm_p, binom_c, binom_p],
    'Stock_Price': [S] * 4,
    'Strike_Price': [K] * 4,
    'Time_To_Maturity': [T] * 4,
    'Volatility_Pct': [sigma * 100] * 4,
    'Risk_Free_Rate_Pct': [6.00] * 4
})

# 6. Delta Analysis
df_delta = pd.DataFrame({
    'Stock_Price': S_range,
    'Call_Delta': deltas_c,
    'Put_Delta': deltas_p,
    'Call_Price': calls,
    'Put_Price': puts
})

# 7. Vega Analysis
df_vega = pd.DataFrame({
    'Volatility_Pct': vol_range * 100,
    'Vega': vegas,
    'Call_Price': calls_vol
})

# 8. Binomial Convergence
df_binomial = pd.DataFrame({
    'Steps': steps,
    'Binomial_Price': prices_b,
    'BSM_Price': [bsm_c] * len(steps),
    'Error': [abs(p - bsm_c) for p in prices_b],
    'Computation_Time_Sec': times
})

# Create output directory
output_dir = os.path.join(os.getcwd(), 'DRM_Output')
os.makedirs(output_dir, exist_ok=True)

print(f"\nOutput Directory: {output_dir}")
print(f"{'=' * 70}")

# Export individual CSV files
print(f"\n[STEP 1] Exporting Individual CSV Files...")
csv_files = {
    '1_Summary': df_summary,
    '2_Stock_Data': df_stock,
    '3_Synthetic_Portfolio': df_synthetic,
    '4_TaskA_Comparison': df_task_a,
    '5_Option_Pricing': df_pricing,
    '6_Delta_Analysis': df_delta,
    '7_Vega_Analysis': df_vega,
    '8_Binomial_Convergence': df_binomial
}

for name, df in csv_files.items():
    csv_path = os.path.join(output_dir, f'{name}.csv')
    df.to_csv(csv_path, index=False)
    print(f"  ✓ Saved: {name}.csv ({len(df)} rows)")

# Export individual Excel files
print(f"\n[STEP 2] Exporting Individual Excel Files...")
for name, df in csv_files.items():
    excel_path = os.path.join(output_dir, f'{name}.xlsx')
    df.to_excel(excel_path, index=False, engine='openpyxl')
    print(f"  ✓ Saved: {name}.xlsx ({len(df)} rows)")

# Export consolidated Excel file
print(f"\n[STEP 3] Exporting Consolidated Excel File...")
consolidated_excel = os.path.join(output_dir, 'DRM_Results_Consolidated.xlsx')

with pd.ExcelWriter(consolidated_excel, engine='openpyxl') as writer:
    df_summary.to_excel(writer, sheet_name='Summary', index=False)
    df_stock.to_excel(writer, sheet_name='Stock_Data', index=False)
    df_synthetic.to_excel(writer, sheet_name='Synthetic_Portfolio', index=False)
    df_task_a.to_excel(writer, sheet_name='TaskA_Comparison', index=False)
    df_pricing.to_excel(writer, sheet_name='Option_Pricing', index=False)
    df_delta.to_excel(writer, sheet_name='Delta_Analysis', index=False)
    df_vega.to_excel(writer, sheet_name='Vega_Analysis', index=False)
    df_binomial.to_excel(writer, sheet_name='Binomial_Convergence', index=False)

print(f"  ✓ Saved: DRM_Results_Consolidated.xlsx (8 sheets)")

# Display all DataFrames
print(f"\n{'=' * 70}")
print(f"DISPLAYING ALL DATAFRAMES")
print(f"{'=' * 70}")

print(f"\n[1] SUMMARY STATISTICS")
print(f"{'-' * 70}")
print(df_summary.to_string(index=False))

print(f"\n\n[2] STOCK DATA (First 10 & Last 10 rows)")
print(f"{'-' * 70}")
print(df_stock.head(10).to_string(index=False))
print("...")
print(df_stock.tail(10).to_string(index=False))

print(f"\n\n[3] SYNTHETIC PORTFOLIO (First 10 & Last 10 rows)")
print(f"{'-' * 70}")
print(df_synthetic.head(10).to_string(index=False))
print("...")
print(df_synthetic.tail(10).to_string(index=False))

print(f"\n\n[4] TASK A COMPARISON")
print(f"{'-' * 70}")
print(df_task_a.to_string(index=False))

print(f"\n\n[5] OPTION PRICING SUMMARY")
print(f"{'-' * 70}")
print(df_pricing.to_string(index=False))

print(f"\n\n[6] DELTA ANALYSIS (First 10 & Last 10 rows)")
print(f"{'-' * 70}")
print(df_delta.head(10).to_string(index=False))
print("...")
print(df_delta.tail(10).to_string(index=False))

print(f"\n\n[7] VEGA ANALYSIS (First 10 & Last 10 rows)")
print(f"{'-' * 70}")
print(df_vega.head(10).to_string(index=False))
print("...")
print(df_vega.tail(10).to_string(index=False))

print(f"\n\n[8] BINOMIAL CONVERGENCE")
print(f"{'-' * 70}")
print(df_binomial.to_string(index=False))

print(f"\n{'=' * 70}")
print(f"EXPORT COMPLETE!")
print(f"{'=' * 70}")
print(f"\nFile Summary:")
print(f"  - Individual CSV files: 8 files")
print(f"  - Individual Excel files: 8 files")
print(f"  - Consolidated Excel: 1 file (8 sheets)")
print(f"  - Total files created: 17 files")
print(f"\nAll files saved to: {output_dir}")
print(f"\nPhase 4 Complete!")Cell 5:
# PHASE 2: SYNTHETIC OPTION PORTFOLIO (TASK A)
# Objective: Construct a synthetic long call using Put-Call Parity
# Strategy: Long Stock + Long Put = Long Call
# We will also implement Dynamic Delta Hedging (Part A)

print(f"\n{'=' * 60}")
print(f"PHASE 2: SYNTHETIC PORTFOLIO & DELTA HEDGING")
print(f"{'=' * 60}")

# Parameters
S0 = float(data['Close'].iloc[0])
K = S0  # ATM Option
r = 0.06  # Risk-free rate (6%)
sigma = vol  # Annualized volatility from Phase 1
T_init = len(data) / 252.0  # Dynamic duration based on data
window = len(data)  # Full history

print(f"Simulation Parameters:")
print(f"  - Initial Stock Price (S0): {S0:.2f}")
print(f"  - Strike Price (K): {K:.2f}")
print(f"  - Risk-Free Rate: {r:.2%}")
print(f"  - Volatility: {sigma:.2%}")
print(f"  - Duration: {T_init} Years ({window} trading days)")

# BSM Price Function
def bsm_price(S, K, T, r, sigma, option_type='call'):
    if T <= 1e-5:
        return max(S - K, 0) if option_type == 'call' else max(K - S, 0)
    
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    
    if option_type == 'call':
        price = S * si.norm.cdf(d1, 0.0, 1.0) - K * np.exp(-r * T) * si.norm.cdf(d2, 0.0, 1.0)
    elif option_type == 'put':
        price = K * np.exp(-r * T) * si.norm.cdf(-d2, 0.0, 1.0) - S * si.norm.cdf(-d1, 0.0, 1.0)
    return price

# BSM Delta Function
def bsm_delta(S, K, T, r, sigma, option_type='call'):
    if T <= 1e-5:
        if option_type == 'call':
            return 1.0 if S > K else 0.0
        else:
            return -1.0 if S < K else 0.0

    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    
    if option_type == 'call':
        return si.norm.cdf(d1)
    else:
        return si.norm.cdf(d1) - 1


# BSM Greeks Function
def bsm_greeks(S, K, T, r, sigma, option_type='call'):
    """
    Calculate all BSM Greeks: Delta, Gamma, Theta, Vega, Rho
    """
    if T <= 1e-5:
        return {'delta': 0, 'gamma': 0, 'theta': 0, 'vega': 0, 'rho': 0}
    
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    
    # Delta
    if option_type == 'call':
        delta = si.norm.cdf(d1)
    else:
        delta = si.norm.cdf(d1) - 1
        
    # Gamma (same for call and put)
    gamma = si.norm.pdf(d1) / (S * sigma * np.sqrt(T))
    
    # Vega (same for call and put)
    # Vega is typically expressed as change in price for 1% change in volatility
    vega = S * si.norm.pdf(d1) * np.sqrt(T) / 100 
    
    # Theta
    # Theta is typically expressed as change in price for 1 day passage of time
    if option_type == 'call':
        theta = (- (S * si.norm.pdf(d1) * sigma) / (2 * np.sqrt(T)) - r * K * np.exp(-r * T) * si.norm.cdf(d2)) / 365
    else:
        theta = (- (S * si.norm.pdf(d1) * sigma) / (2 * np.sqrt(T)) + r * K * np.exp(-r * T) * si.norm.cdf(-d2)) / 365
        
    # Rho
    # Rho is typically expressed as change in price for 1% change in interest rate
    if option_type == 'call':
        rho = (K * T * np.exp(-r * T) * si.norm.cdf(d2)) / 100
    else:
        rho = (-K * T * np.exp(-r * T) * si.norm.cdf(-d2)) / 100
        
    return {
        'delta': delta,
        'gamma': gamma,
        'theta': theta,
        'vega': vega,
        'rho': rho
    }
# Initial Prices
call_init = bsm_price(S0, K, T_init, r, sigma, 'call')
put_init = bsm_price(S0, K, T_init, r, sigma, 'put')

print(f"\nInitial Option Prices (Theoretical):")
print(f"  - ATM Call Price: {call_init:.2f}")
print(f"  - ATM Put Price: {put_init:.2f}")

# Storage for Synthetic Portfolio (Static)
synth_nav = []
dates = []
stock_prices = []
put_prices = []
parity_diff = []

# Storage for Delta Hedging (Dynamic)
hedged_portfolio_value = []
cash_account = []
stock_position = []
call_position_value = []

# Initial Setup for Delta Hedging
initial_delta = bsm_delta(S0, K, T_init, r, sigma, 'call')
shares_held = initial_delta
cash_balance = call_init - (shares_held * S0) # Receive Call Premium, Pay for Stock

print(f"\nStarting Simulations...")

for i in range(window):
    date = data.index[i]
    S_t = float(data['Close'].iloc[i])
    
    # Time to maturity (decaying)
    T_t = max(T_init - (i / 252.0), 1e-5)
    
    # --- 1. Static Synthetic Portfolio Tracking ---
    put_price_t = bsm_price(S_t, K, T_t, r, sigma, 'put')
    synth_value_t = S_t + put_price_t
    
    synth_nav.append(synth_value_t)
    dates.append(date)
    stock_prices.append(S_t)
    put_prices.append(put_price_t)
    
    # Put-Call Parity Check
    call_price_t = bsm_price(S_t, K, T_t, r, sigma, 'call')
    pv_k = K * np.exp(-r * T_t)
    parity_error = (S_t + put_price_t) - (call_price_t + pv_k)
    parity_diff.append(parity_error)
    
    # --- 2. Dynamic Delta Hedging Tracking ---
    current_delta = bsm_delta(S_t, K, T_t, r, sigma, 'call')
    delta_change = current_delta - shares_held
    
    # Update Cash (assume risk-free growth on cash balance for 1 day)
    dt = 1/252.0
    cash_balance = cash_balance * np.exp(r * dt) - (delta_change * S_t)
    
    shares_held = current_delta
    
    # Portfolio Value
    call_liability = call_price_t
    pf_value = (shares_held * S_t) + cash_balance - call_liability
    hedged_portfolio_value.append(pf_value)
    cash_account.append(cash_balance)
    stock_position.append(shares_held)
    call_position_value.append(call_liability)

# Final Calculations
final_synth_value = synth_nav[-1]
initial_synth_cost = S0 + put_init
pnl_synth = final_synth_value - initial_synth_cost

final_hedged_value = hedged_portfolio_value[-1]

print(f"\nSimulation Complete!")
print(f"Synthetic Portfolio (Static):")
print(f"  - Final Value: {final_synth_value:.2f}")
print(f"  - Initial Cost: {initial_synth_cost:.2f}")
print(f"  - P&L: {pnl_synth:.2f}")
print(f"Delta Hedging (Dynamic):")
print(f"  - Final Hedged P&L: {final_hedged_value:.2f} (Should be close to 0)")

# Create DataFrame for Analysis
df_res = pd.DataFrame({
    'Date': dates,
    'Stock': stock_prices,
    'Synthetic': synth_nav,
    'Hedged_PnL': hedged_portfolio_value,
    'Parity_Error': parity_diff
})
df_res.set_index('Date', inplace=True)

# Visualization
fig, axes = plt.subplots(3, 1, figsize=(14, 18))

# 1. Synthetic Portfolio
axes[0].plot(df_res.index, df_res['Synthetic'], label='Synthetic Call (Long Stock + Long Put)', color='orange')
# Calculate Theoretical Call + PV(K) for comparison
theo_vals = []
for i in range(len(stock_prices)):
    S_t = stock_prices[i]
    T_t = max(T_init - (i/252.0), 1e-5)
    c = bsm_price(S_t, K, T_t, r, sigma, 'call')
    theo_vals.append(c + K * np.exp(-r * T_t))
axes[0].plot(df_res.index, theo_vals, label='Theoretical Call + PV(K)', linestyle='--', color='blue')
axes[0].set_title('Put-Call Parity Check (Static Portfolio)', fontsize=14)
axes[0].legend()
axes[0].grid(True)

# 2. Parity Error
axes[1].plot(df_res.index, df_res['Parity_Error'], color='red')
axes[1].set_title('Parity Error (Synthetic - Theoretical)', fontsize=14)
axes[1].grid(True)

# 3. Delta Hedging
axes[2].plot(df_res.index, df_res['Hedged_PnL'], color='green')
axes[2].set_title('Dynamic Delta Hedging P&L (Cumulative)', fontsize=14)
axes[2].axhline(0, color='black', linestyle='--')
axes[2].grid(True)

plt.tight_layout()
plt.show()

====================
Cell 11:
# PHASE 3 - TASK B: BSM MODEL & GREEKS

def bsm_greeks(S, K, T, r, sigma):
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    
    delta_call = si.norm.cdf(d1)
    delta_put = delta_call - 1
    vega = S * si.norm.pdf(d1) * np.sqrt(T)
    
    return delta_call, delta_put, vega

print(f"{'=' * 70}")
print(f"BLACK-SCHOLES-MERTON MODEL & GREEKS ANALYSIS")
print(f"{'=' * 70}")

S = float(data['Close'].iloc[-1])
K = S
T = 1/12
r = 0.06
sigma = vol

print(f"\nAnalysis Parameters:")
print(f"  - Stock Price: {S:.2f}")
print(f"  - Strike: {K:.2f} [ATM]")
print(f"  - Time to Maturity: {T:.4f} years")
print(f"  - Risk-Free Rate: {r:.2%}")
print(f"  - Volatility: {sigma:.2%}")

call_atm = bsm_price(S, K, T, r, sigma, 'call')
put_atm = bsm_price(S, K, T, r, sigma, 'put')
delta_c, delta_p, vega_atm = bsm_greeks(S, K, T, r, sigma)

print(f"\nATM Option Valuations:")
print(f"  - Call Price: {call_atm:.2f}")
print(f"  - Put Price: {put_atm:.2f}")
print(f"  - Call Delta: {delta_c:.4f}")
print(f"  - Put Delta: {delta_p:.4f}")
print(f"  - Vega: {vega_atm:.2f}")

S_range = np.linspace(S * 0.8, S * 1.2, 100)

deltas_c = []
deltas_p = []
calls = []
puts = []

for s in S_range:
    c = bsm_price(s, K, T, r, sigma, 'call')
    p = bsm_price(s, K, T, r, sigma, 'put')
    dc, dp, _ = bsm_greeks(s, K, T, r, sigma)
    
    calls.append(c)
    puts.append(p)
    deltas_c.append(dc)
    deltas_p.append(dp)

vol_range = np.linspace(0.10, 0.50, 100)

vegas = []
calls_vol = []

for v in vol_range:
    _, _, vega = bsm_greeks(S, K, T, r, v)
    c = bsm_price(S, K, T, r, v, 'call')
    vegas.append(vega)
    calls_vol.append(c)

max_vega = max(vegas)
idx_max = vegas.index(max_vega)
vol_opt = vol_range[idx_max]

fig, axes = plt.subplots(2, 2, figsize=(16, 10))

ax1 = axes[0, 0]
ax1.plot(S_range, deltas_c, label='Call Delta', color='green', linewidth=2.5)
ax1.plot(S_range, deltas_p, label='Put Delta', color='red', linewidth=2.5)
ax1.axvline(x=K, color='black', linestyle='--', alpha=0.6, label=f'Strike: {K:.2f}')
ax1.axhline(y=0.5, color='orange', linestyle=':', alpha=0.6, label='Delta = 0.5')
ax1.axhline(y=0, color='gray', linestyle='-', alpha=0.3)
ax1.set_title('Delta vs Stock Price', fontsize=12, fontweight='bold')
ax1.set_xlabel('Stock Price', fontsize=10)
ax1.set_ylabel('Delta', fontsize=10)
ax1.legend(loc='best', fontsize=9)
ax1.grid(True, alpha=0.3)
ax1.set_ylim(-1.1, 1.1)

ax2 = axes[0, 1]
ax2.plot(vol_range * 100, vegas, label='Vega', color='blue', linewidth=2.5)
ax2.axvline(x=sigma * 100, color='red', linestyle='--', alpha=0.6, 
            label=f'Current: {sigma:.2%}')
ax2.axvline(x=vol_opt * 100, color='orange', linestyle=':', alpha=0.6, 
            label=f'Max Vega: {vol_opt:.2%}')
ax2.set_title('Vega vs Volatility', fontsize=12, fontweight='bold')
ax2.set_xlabel('Volatility (%)', fontsize=10)
ax2.set_ylabel('Vega', fontsize=10)
ax2.legend(loc='best', fontsize=9)
ax2.grid(True, alpha=0.3)

ax3 = axes[1, 0]
ax3.plot(S_range, calls, label='Call Price', color='darkgreen', linewidth=2.5)
ax3.plot(S_range, puts, label='Put Price', color='darkred', linewidth=2.5)
ax3.axvline(x=K, color='black', linestyle='--', alpha=0.6, label=f'Strike: {K:.2f}')
ax3.set_title('Option Prices vs Stock Price', fontsize=12, fontweight='bold')
ax3.set_xlabel('Stock Price', fontsize=10)
ax3.set_ylabel('Option Price', fontsize=10)
ax3.legend(loc='best', fontsize=9)
ax3.grid(True, alpha=0.3)

ax4 = axes[1, 1]
ax4.plot(vol_range * 100, calls_vol, label='Call Price', color='purple', linewidth=2.5)
ax4.axvline(x=sigma * 100, color='red', linestyle='--', alpha=0.6, 
            label=f'Current: {sigma:.2%}')
ax4.set_title('Call Price vs Volatility', fontsize=12, fontweight='bold')
ax4.set_xlabel('Volatility (%)', fontsize=10)
ax4.set_ylabel('Call Price', fontsize=10)
ax4.legend(loc='best', fontsize=9)
ax4.grid(True, alpha=0.3)

plt.suptitle('Black-Scholes-Merton Model: Greeks Analysis', 
             fontsize=16, fontweight='bold', y=0.995)
plt.tight_layout()
plt.show()

print(f"\nPhase 3 Task B Complete!")

====================
